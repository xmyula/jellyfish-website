<!DOCTYPE html>
<html>
<head>
  <base target="_top">
  <meta charset="UTF-8">
  <title>åˆæˆå¤§æ°´æ¯</title>
  <style>

   #gameWrapper {
  width: 600px;
  margin: 0 auto;
  transform: scale(0.8);
  transform-origin: top center;
}

canvas {
  background: #e0f7fa;
  display: block;
  margin: auto;
}

    

  #rankingBox {
    width: 400px;
    margin: 10px auto;
    padding: 10px;
    background: #e0f2f1;
    border-radius: 10px;
    font-family: Arial;
  }

  #rankingBox h3 {
    margin: 5px 0;
    text-align: center;
    color: #004d40;
  }

  #rankingList {
    padding-left: 20px;
  }

  #rankingList li {
    margin: 4px 0;
  }

  #rankingBox {
  position: fixed;
  right: 10px;
  top: 80px;
  width: 180px;
  background: rgba(255, 255, 255, 0.9);
  border-radius: 12px;
  padding: 10px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.2);
  font-family: Arial, sans-serif;
}

#rankingBox h3 {
  margin: 0 0 8px 0;
  font-size: 16px;
  text-align: center;
}

#rankingList {
  padding-left: 20px;
  margin: 0;
  font-size: 14px;
}

#rankingList li.me {
  font-weight: bold;
  color: #d32f2f;
}

#helpBox {
  position: fixed;
  left: 10px;
  top: 80px;
  width: 180px;
  background: rgba(255,255,255,0.9);
  border-radius: 12px;
  padding: 10px;
  font-family: Arial, sans-serif;
  box-shadow: 0 4px 10px rgba(0,0,0,0.2);
}

#helpBox h3 {
  margin: 0 0 8px 0;
  font-size: 16px;
  text-align: center;
}

#helpBox ul {
  padding-left: 18px;
  font-size: 13px;
  margin: 0;
}


  </style>
</head>

<body>

<h2 style="text-align:center;">åˆæˆå¤§æ°´æ¯ ğŸª¼</h2>

<div id="helpBox">
  <h3>ğŸ® æ“ä½œèªªæ˜</h3>
  <ul>
    <li>éµç›¤æ“ä½œï¼š</li>
    <li>â¬…â¡å·¦å³éµæ§åˆ¶æ°´æ¯ç§»å‹•</li>
    <li>ç©ºç™½éµ è½ä¸‹</li>
    <li>æ»‘é¼ æ“ä½œï¼š</li>
    <li>ğŸ–±æ»‘é¼ æ§åˆ¶æ°´æ¯ç§»å‹•</li>
    <li>ğŸ–±æ»‘é¼ å·¦éµ è½ä¸‹</li>
    <li>ğŸª¼ç›¸åŒæ°´æ¯æœƒåˆæˆ</li>
    <li>ğŸš¨æ°´æ¯è¶…éä¸Šæ–¹3ç§’å³çµæŸ</li>
  </ul>
</div>

<div id="gameWrapper">
  <canvas id="game" width="600" height="620" tabindex="1"></canvas>
</div>

<div id="rankingBox">
  <div id="nextBox">
  <h3>ğŸª¼ ä¸‹ä¸€å€‹</h3>
  <img id="nextImg">
</div>

  <h3>ğŸ† æ’è¡Œæ¦œ TOP 10</h3>
  <ol id="rankingList"></ol>
  <button onclick="location.href='ranking.html'" style="margin-top:8px; width:100%; cursor:pointer; background:#00796b; color:white; border:none; border-radius:4px; padding:5px;">
  æŸ¥çœ‹å®Œæ•´æ’è¡Œ
</button>
</div>

<script>
window.onload = () => {
  startRankingAutoUpdate();
  gameLoop();
};

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");


const jellyfishImages = {
  1: "https://lh3.googleusercontent.com/d/1Yvajk0RLnuHwb4TLZ4Of0W4W4M9lHo7F",
  2: "https://lh3.googleusercontent.com/d/1PKA0RkkIeF_dH1MNaTQaHjAIXkjuc8W3",
  3: "https://lh3.googleusercontent.com/d/1UEogPGXmXFtqXhZegyrwC0VLNPQyU3jq",
  4: "https://lh3.googleusercontent.com/d/1Ota1YjLCAMtOVfx_6MkwhYdKNBF0h7lo",
  5: "https://lh3.googleusercontent.com/d/1BIS9uWe7i4TdqDRiSLNzz5kzcJVKx9AT",
  6: "https://lh3.googleusercontent.com/d/1pbv3Psw_p_GomoCDwXMMZoEUXIigTpW0",
  7: "https://lh3.googleusercontent.com/d/1x9xBTn0Ewx9C0rCmqW_1vCYiRuKXIXpi",
  8: "https://lh3.googleusercontent.com/d/1GZsqHswd8_t-HcBWsxPcX21m1997n44u",
  9: "https://lh3.googleusercontent.com/d/1oFj1JoSv6f1KNB42GB57GhqT8rYzF05e",
  10: "https://lh3.googleusercontent.com/d/1E2bOt5xpmn5qAHCMOdHEcaKnNY_tpdeM",
  11: "https://lh3.googleusercontent.com/d/1sPHlZYil3vfK0QoSuQoTkWJOpZ-sJp3F"

};

  const imageCache = {};

for (let i = 1; i <= 11; i++) {
  const img = new Image();
  img.src = jellyfishImages[i];
  imageCache[i] = img;
}

function randomLevel() {
  return Math.floor(Math.random() * 5) + 1;
}

let nextLevel = randomLevel();

const SPACING = 4; 

function clampJellyfish(j) {
  // å·¦
  if (j.x < j.radius) {
    j.x = j.radius;
  }

  // å³
  if (j.x > canvas.width - j.radius) {
    j.x = canvas.width - j.radius;
  }

  // ä¸‹ï¼ˆåœ°æ¿ï¼‰
  if (j.y > groundY - j.radius) {
    j.y = groundY - j.radius;
    j.vy = 0;
  }
}

function updateNextPreview() {
  const img = document.getElementById("nextImg");
  if (!img) return;
  img.src = jellyfishImages[nextLevel];
}


class Jellyfish {
  constructor(x, y, level) {
    this.x = x;
    this.y = y;
    this.level = level;
    this.radius = 20 + Math.pow(level, 1.4) * 4;
    this.vx = 0;
    this.vy = 0;
    this.isDropping = false;
    this.isSleeping = false;
    this.lastX = x;
    this.lastY = y;
    this.jitterCount = 0;
    this.smoothSpeed = 0;
    this.jitterLock = false;
    this.jitterLockTimer = 0;

  }

update() {
  if (!this.isSleeping) {
    this.vy = Math.min(this.vy + 1.5, 15);
  }

  this.x += this.vx;
  this.y += this.vy;

  if (this.y + this.radius >= groundY) {
    this.y = groundY - this.radius;
    this.vy = 0;
    this.isSleeping = true;
  }

 if (this.isSleeping) {
  this.vx *= 0.6;
  this.vy *= 0.6;

  if (Math.abs(this.vx) < 0.02) this.vx = 0;
  if (Math.abs(this.vy) < 0.02) this.vy = 0;
}

if (hasSupport(this) && Math.abs(this.vy) < 0.6) {
  this.vy *= 0.15;
}

const instantSpeed = Math.abs(this.vx) + Math.abs(this.vy);
this.smoothSpeed = this.smoothSpeed * 0.85 + instantSpeed * 0.15;
const dx = this.x - this.lastX;
const dy = this.y - this.lastY;
const moveDist = Math.sqrt(dx * dx + dy * dy);

if (moveDist < 0.25 && this.smoothSpeed > 0.25) {
  this.jitterCount++;

  if (this.jitterCount > 12 && !this.jitterLock) {
    this.jitterLock = true;
    this.jitterLockTimer = 0;
  }
} else {
  this.jitterCount = 0;
}


this.lastX = this.x;
this.lastY = this.y;


if (this.jitterCount > 40) {
  this.vx = 0;
  this.vy = 0;
  this.isSleeping = true;
  this.jitterCount = 0;
}

if (this.jitterLock) {
  this.jitterLockTimer++;

  if (Math.abs(this.vy) < 0.8) {
    this.vy *= 0.1;
  }

  if (Math.abs(this.vx) < 0.8) {
    this.vx *= 0.1;
  }

  if (this.jitterLockTimer > 24) {
    this.jitterLock = false;
    this.jitterLockTimer = 0;
  }
}

}

  draw() {
    const img = imageCache[this.level];
    if (!img) return;

    ctx.drawImage(
      img,
      this.x - this.radius,
      this.y - this.radius,
      this.radius * 2,
      this.radius * 2
    );
  }
}

function drawDangerOverlay(remainingTime) {
  const alpha = Math.min(0.6, 1 - remainingTime / DANGER_TIME);

  const gradient = ctx.createRadialGradient(
    canvas.width / 2,
    canvas.height / 2,
    50,
    canvas.width / 2,
    canvas.height / 2,
    Math.max(canvas.width, canvas.height)
  );

  gradient.addColorStop(0, `rgba(255,0,0,0)`);
  gradient.addColorStop(1, `rgba(255,0,0,${alpha})`);

  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // ç´…è‰²é‚Šæ¡†
  ctx.strokeStyle = `rgba(255,0,0,${alpha + 0.2})`;
  ctx.lineWidth = 8;
  ctx.strokeRect(0, 0, canvas.width, canvas.height);
}

let currentJellyfish = createNewJellyfish();

// éµç›¤æ§åˆ¶
document.addEventListener("keydown", e => {
  if (["ArrowLeft", "ArrowRight", " "].includes(e.key)) {
    e.preventDefault();
  }
  if (!currentJellyfish) return;

  if (e.key === " ") {
    currentJellyfish.isDropping = true;
    currentJellyfish.isSleeping = false;
  }
  if (e.key === "ArrowLeft") {
  currentJellyfish.x = Math.max(currentJellyfish.radius, currentJellyfish.x - 15);
}
if (e.key === "ArrowRight") {
  currentJellyfish.x = Math.min(canvas.width - currentJellyfish.radius, currentJellyfish.x + 15);
}

});

document.addEventListener("keyup", e => {
  if (!currentJellyfish) return;

  if (e.key === " ") {
    currentJellyfish.isDropping = true;
    currentJellyfish.isSleeping = false;
  }
});


// æ»‘é¼ æ§åˆ¶
canvas.addEventListener("mouseup", () => {
  if (currentJellyfish) {
    currentJellyfish.isDropping = true;
    currentJellyfish.isSleeping = false; 
  }
});


canvas.addEventListener("mousemove", e => {
  if (currentJellyfish && !currentJellyfish.isDropping) {
    currentJellyfish.x = e.offsetX;
    clampJellyfish(currentJellyfish);
  }
});

/* =========================
   â‘£ æ¸¬è©¦ï¼šç•«ä¸€éš»æ°´æ¯
========================= */

function createNewJellyfish() {
  const x = Math.random() * (canvas.width - 60) + 30;

  const j = new Jellyfish(x, 50, nextLevel);

  nextLevel = randomLevel();   
  updateNextPreview();        

  j.isSleeping = true;
  return j;
}

const groundY = canvas.height - 20;
const jellyfishes = [];

function drawCountdown(remainingMs) {
  const seconds = Math.ceil(remainingMs / 1000);

  ctx.fillStyle = "rgba(255, 0, 0, 0.9)";
  ctx.font = "bold 48px Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";

  ctx.fillText(
    seconds,
    canvas.width / 2,
    canvas.height / 2
  );
}


function gameLoop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  drawScore();

  // åœ°æ¿
  ctx.fillStyle = "#006064";
  ctx.fillRect(0, groundY, canvas.width, 5);


if (currentJellyfish) {
  currentJellyfish.update();
  clampJellyfish(currentJellyfish);
  currentJellyfish.draw();

  if (currentJellyfish.isDropping) {
    let landingY = groundY - currentJellyfish.radius;

    for (const j of jellyfishes) {
      const dx = Math.abs(currentJellyfish.x - j.x);
      const overlapX = dx < currentJellyfish.radius + j.radius;

      if (overlapX) {
        const possibleY =
          j.y - j.radius - currentJellyfish.radius - SPACING;
        if (possibleY < landingY) {
          landingY = possibleY;
        }
      }
    } 

    if (currentJellyfish.y >= landingY) {
      currentJellyfish.y = landingY;
      currentJellyfish.vy = 0;
      currentJellyfish.isDropping = false;
      currentJellyfish.isSleeping = true;

      jellyfishes.push(currentJellyfish);
      currentJellyfish = createNewJellyfish();
    }
  }
}

  for (let i = 0; i < jellyfishes.length; i++) {
    for (let j = i + 1; j < jellyfishes.length; j++) {
      const a = jellyfishes[i];
      const b = jellyfishes[j];

      if (isColliding(a, b)) {
        if (a.level === b.level) {
          mergeJellyfish(i, j);
          break;
        } else {
          resolveCollision(a, b);
          
        }
      }
    }
  }
jellyfishes.forEach(j => {
  if (!hasSupport(j)) {
    j.isSleeping = false;
  }

  j.update();
  clampJellyfish(j);
  j.draw();
});


 let anyOverTop = false;

for (const j of jellyfishes) {
  if (j.y - j.radius <= 0) {
    anyOverTop = true;
    break;
  }
}

if (anyOverTop) {
  if (overTopStartTime === null) {
    overTopStartTime = Date.now();
  } else {
    const elapsed = Date.now() - overTopStartTime;
    const remaining = Math.max(0, DANGER_TIME - elapsed);

    drawDangerOverlay(remaining);
    drawCountdown(remaining);

    if (elapsed > DANGER_TIME) {
      endGame();
      return;
    }
  }
} else {
  overTopStartTime = null;
}

  requestAnimationFrame(gameLoop);
}
  
function isColliding(a, b) {
  const dx = a.x - b.x;
  const dy = a.y - b.y;
  const distance = Math.sqrt(dx * dx + dy * dy);
  return distance < a.radius + b.radius - 1;

}

function hasSupport(jelly) {
  // åœ°æ¿æ”¯æ’
  if (jelly.y + jelly.radius >= groundY - 1) {
    return true;
  }

  // å…¶ä»–æ°´æ¯æ”¯æ’
  for (const other of jellyfishes) {
    if (other === jelly) continue;

    const dx = Math.abs(jelly.x - other.x);
    const overlapX = dx < jelly.radius + other.radius - 2;

    const dy = other.y - jelly.y;
    const touchingFromBelow =
      dy > 0 &&
      Math.abs(dy - (jelly.radius + other.radius)) < 3;

    if (overlapX && touchingFromBelow) {
      return true;
    }
  }

  return false;
}

function resolveCollision(a, b) {
  const dx = b.x - a.x;
  const dy = b.y - a.y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const minDist = a.radius + b.radius + SPACING;

  if (dist === 0 || dist >= minDist) return;

  const overlap = minDist - dist;

  const nx = dx / dist;
  const ny = dy / dist;

  a.x -= nx * overlap / 2;
  a.y -= ny * overlap / 2;
  b.x += nx * overlap / 2;
  b.y += ny * overlap / 2;

  a.vx -= nx * 0.15;
  a.vy -= ny * 0.15;
  b.vx += nx * 0.15;
  b.vy += ny * 0.15;


  a.isSleeping = false;
  b.isSleeping = false;

  clampJellyfish(a); 
  clampJellyfish(b);

}

function drawScore() {
  ctx.fillStyle = "#004d40";
  ctx.font = "20px Arial";
  ctx.textAlign = "left";
  ctx.fillText(`Score: ${score}`, 10, 30);
}

const scoreTable = {
  1: 1,
  2: 3,
  3: 6,
  4: 10,
  5: 15,
  6: 21,
  7: 28,
  8: 36,
  9: 45,
  10: 55,
  11: 66
};

let score = 0;

function mergeJellyfish(i, j) {
  const j1 = jellyfishes[i];
  const j2 = jellyfishes[j];

  if (!j1 || !j2) return;
  if (j1.level !== j2.level) return;

  score += scoreTable[j1.level];

  const x = (j1.x + j2.x) / 2;
  const y = (j1.y + j2.y) / 2;
  const newLevel = j1.level + 1;

  jellyfishes.splice(j, 1);
  jellyfishes.splice(i, 1);

  if (newLevel > 11) return;

  jellyfishes.push(new Jellyfish(x, y, newLevel));
}

let overTopStartTime = null;
const DANGER_TIME = 3000; 

let gameEnded = false;

function saveScoreToServer(name, score) {
  fetch(
    RANKING_API +
      "?action=save" +
      "&name=" + encodeURIComponent(name) +
      "&score=" + score
  );
}


function showRanking() {
  fetch(RANKING_API + "?action=get")
    .then(res => res.json())
    .then(data => {
      const list = document.getElementById("rankingList");
      list.innerHTML = "";

      if (!Array.isArray(data) || data.length === 0) {
        const li = document.createElement("li");
        li.textContent = "å°šç„¡æ’è¡Œæ¦œè³‡æ–™";
        list.appendChild(li);
        return;
      }

      // âœ… ç‰©ä»¶ APIï¼šåªå–å‰ 10 å
      data.slice(0, 10).forEach((item, i) => {
        const li = document.createElement("li");
        li.textContent = `${item.name ?? "åŒ¿å"} - ${item.score} åˆ†`;

        if (playerName && item.name === playerName) {
          li.classList.add("me");
          li.textContent += " ğŸ”¸";
        }

        list.appendChild(li);
      });
    })
    .catch(err => {
      console.error(err);
    });
}


function endGame() {
  if (gameEnded) return;
  gameEnded = true;

  stopRankingAutoUpdate();

  setTimeout(() => {
    const name = prompt("éŠæˆ²çµæŸï¼è«‹è¼¸å…¥ä½ çš„æš±ç¨±ï¼š");
    playerName = name && name.trim() !== "" ? name.trim() : "åŒ¿å";
    saveScoreToServer(playerName, score);
    setTimeout(showRanking, 800);
  }, 100);
}
    
let rankingTimer = null;
let playerName = null;
let myRank = null
  
function startRankingAutoUpdate() {
  showRanking(); 
}

function stopRankingAutoUpdate() {
  if (rankingTimer) {
    clearInterval(rankingTimer);
    rankingTimer = null;
  }
}

const RANKING_API =
  "https://script.google.com/macros/s/AKfycbz4eLqftorbn4OW3-Y5h-b7XMehahhc5oYxaKBVYJhaweI_9gLewoUsuEnXwdgsj27f5w/exec";

</script>

</body>
</html>
